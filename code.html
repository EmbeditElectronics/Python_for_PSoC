<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>API modules &mdash; RPiSoC Python API 1.2.4 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.2.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="RPiSoC Python API 1.2.4 documentation" href="index.html" />
    <link rel="next" title="Making Changes to the API" href="making_changes.html" />
    <link rel="prev" title="Getting Started" href="getting_started.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="making_changes.html" title="Making Changes to the API"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="getting_started.html" title="Getting Started"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">RPiSoC Python API 1.2.4 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="api-modules">
<h1>API modules<a class="headerlink" href="#api-modules" title="Permalink to this headline">¶</a></h1>
<p>Here is a quick look at what is under the hood of the RPiSoC Python API, as of <em>V1.1.1</em></p>
<div class="section" id="rpisoc-py">
<h2>rpisoc.py<a class="headerlink" href="#rpisoc-py" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>This is the highest level module import for the RPiSoC API, which the user should</dt>
<dd>import into their scripts for full use of it. It is used to keep records of some globally used variables between all classes.</dd>
</dl>
<p>It is also used to send data to, and receive data from the RPiSoC using
a user chosen communication protocol.</p>
<p>At the beginning of each script, insert the following
two lines:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">rpisoc</span> <span class="kn">import</span> <span class="o">*</span> <span class="c">#This will handle dependencies</span>
<span class="n">RPiSoC</span><span class="p">(</span><span class="s">&#39;SPI&#39;</span><span class="p">)</span>
<span class="c">#or RPiSoC(&#39;I2C&#39;)</span>
</pre></div>
</div>
<span class="target" id="module-rpisoc"></span><p>This program is the highest level module for the RPiSoC API, which the user should
import into their scripts for full use of the API.</p>
<dl class="function">
<dt id="rpisoc.Check_Analog">
<tt class="descclassname">rpisoc.</tt><tt class="descname">Check_Analog</tt><big>(</big><big>)</big><a class="headerlink" href="#rpisoc.Check_Analog" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Used to collect analog data from the RPiSoC during run-time</dd>
<dt><strong>Returns:</strong></dt>
<dd><em>data:</em> The number of DACs, ADCs, analog pins, and capsense pins found. Refer to the code for unpacking process.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="rpisoc.Check_GPIO">
<tt class="descclassname">rpisoc.</tt><tt class="descname">Check_GPIO</tt><big>(</big><em>block</em><big>)</big><a class="headerlink" href="#rpisoc.Check_GPIO" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Used to collect GPIO data from the RPiSoC during run-time</dd>
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><em>block:</em> describes which &#8220;block&#8221; of GPIO you are making a queery for.</dt>
<dd><ul class="first last simple">
<li>block = 0 is for ports 0, 2, and 3</li>
<li>block = 1 is for ports 4, 5, and 6</li>
<li>block = 2 is for ports 12 and 15</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>Returns:</strong></dt>
<dd><em>data:</em> A binary number, each bit of which represents the presense of a particular pin.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="rpisoc.Check_PWM">
<tt class="descclassname">rpisoc.</tt><tt class="descname">Check_PWM</tt><big>(</big><big>)</big><a class="headerlink" href="#rpisoc.Check_PWM" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Used to collect PWM data from the RPiSoC during run-time</dd>
<dt><strong>Returns:</strong></dt>
<dd><em>data:</em> The number of PWM blocks found on the RPiSoC(data&gt;&gt;4), and the number of unique clocks driving them (first 4 bits).</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="rpisoc.Get_Clocks">
<tt class="descclassname">rpisoc.</tt><tt class="descname">Get_Clocks</tt><big>(</big><em>clk_num</em><big>)</big><a class="headerlink" href="#rpisoc.Get_Clocks" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Used to get information about the clocks driving the PWM&#8217;s, specifically their frequency and default divider, as well as their assigned tag number for matching.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><em>clk_num:</em> The number of clocks in the build, which is discovered from the Check_PWM() function.</dd>
<dt><strong>Returns:</strong></dt>
<dd><em>clk_dat:</em> a list containing raw data for each individual clock.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="rpisoc.I2C">
<em class="property">class </em><tt class="descclassname">rpisoc.</tt><tt class="descname">I2C</tt><big>(</big><em>bus_location=1</em>, <em>f_address=8</em><big>)</big><a class="headerlink" href="#rpisoc.I2C" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>This class defines usage of the I2C bus for transfer between the RPi and the PSoC. __init__ is called as soon as an <em>RPiSoC</em> object is defined, and it opens and configures the bus.</dd>
<dt><strong>Note:</strong></dt>
<dd>i2c must be configured and the smbus libraries must be installed to call this class</dd>
</dl>
<p><strong>Parameters:</strong></p>
<p><em>bus_location:</em> location of the smbus on the pi, it is defaulted to 1 but confirm
with:</p>
<div class="highlight-python"><div class="highlight"><pre>i2cdetect -y 1
</pre></div>
</div>
<p>If this command is written to the terminal, and the addres <em>08</em> is not shown, then
try:</p>
<div class="highlight-python"><div class="highlight"><pre>i2cdetect -y 0
</pre></div>
</div>
<p>If that successfully shows the RPiSoC&#8217;s address of <em>08</em>, then change this parameter to <em>0.</em>
If neither command shows the correct address, verify your connection, and verify that you have
correctly configured and enabled i2c.</p>
<p><em>f_address:</em> The i2c address on the RPiSoC. It is set to 0x08 by default. If you change the address on the
RPiSoC, that change must be reflected here.</p>
<dl class="method">
<dt id="rpisoc.I2C.PrepareData">
<tt class="descname">PrepareData</tt><big>(</big><em>dat</em><big>)</big><a class="headerlink" href="#rpisoc.I2C.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Makes sure that the data being sent is correctly formatted, so that the RPiSoC is able to more easily decode the received words.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><em>dat:</em> A tuple of length 2 or 3</dt>
<dd><ul class="first last simple">
<li>The size of the first two items of the tuple must be less than or equal to one byte each.</li>
<li>The size of the third item in the tuple, if applicable, must be less than or equal to two bytes.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Returns:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>A list of length 4, prepared for SPI transfer, with the following construction:</dt>
<dd><ul class="first last simple">
<li>[dat[0], dat[1], dat[2]__LOW_BYTE, dat[2]__HIGH_BYTE]</li>
<li>The RPiSoC is expecting receipt of these 4 bytes, in this order.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="rpisoc.I2C.__init__">
<tt class="descname">__init__</tt><big>(</big><em>bus_location=1</em>, <em>f_address=8</em><big>)</big><a class="headerlink" href="#rpisoc.I2C.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Parameters:</strong></p>
<blockquote>
<div><p><em>bus_location:</em> location of the smbus on the pi, it is defaulted to 1 but confirm
with:</p>
<div class="highlight-python"><div class="highlight"><pre>i2cdetect -y 1
</pre></div>
</div>
<p>If this command is written to the terminal, and the addres <em>08</em> is not shown, then
try:</p>
<div class="highlight-python"><div class="highlight"><pre>i2cdetect -y 0
</pre></div>
</div>
<p>If that successfully shows the RPiSoC&#8217;s address of <em>08</em>, then change this parameter to <em>0.</em>
If neither command shows the correct address, verify your connection, and verify that you have
correctly configured and enabled i2c.</p>
<p><em>f_address:</em> The i2c address on the RPiSoC. It is set to 0x08 by default. If you change the address on the
RPiSoC, that change must be reflected here.</p>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="rpisoc.I2C.cleanup">
<tt class="descname">cleanup</tt><big>(</big><big>)</big><a class="headerlink" href="#rpisoc.I2C.cleanup" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Forces a software reset on the RPiSoC to clean up its GPIO.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="rpisoc.I2C.receiveData">
<tt class="descname">receiveData</tt><big>(</big><em>vals</em>, <em>delay=0.05</em><big>)</big><a class="headerlink" href="#rpisoc.I2C.receiveData" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>This function is called when the RPi desires a returned value from the RPiSoC. It will send a command, and then wait for a response.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><em>vals:</em> A tuple which will be sent to the <em>PrepareData()</em> function to be restructured into a list of length 4 and then sent to the RPiSoC over I2C.</dd>
<dt><strong>Optional Parameter:</strong></dt>
<dd><em>delay:</em> The amount of time that the Python code will wait after sending a request, and before expecting a response. This is to be used when one is requesting a complex operation, and more time is needed by the RPiSoC to generate a result.</dd>
<dt><strong>Returns:</strong></dt>
<dd><dl class="first last docutils">
<dt>The data packet received from the PSoC, which has been unpacked and reformatted.</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>Since the largest possible value that the PSoC will generally send is a 20 bit number, if the RPi receives a number that is sufficiently large, it will assume that the number overflowed backwards because the PSoC tried to send a negative number.</dt>
<dd><ul class="first last simple">
<li>It will account for this by subtracting (2^32 - 1) from the received data, if that data is larger than (2^26 -1)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="rpisoc.I2C.sendData">
<tt class="descname">sendData</tt><big>(</big><em>vals</em><big>)</big><a class="headerlink" href="#rpisoc.I2C.sendData" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>This function will send data to the RPiSoC, without waiting for a return</dd>
<dt><strong>Parameters:</strong></dt>
<dd><em>vals:</em> A tuple which will be sent to the <em>PrepareData()</em> method to be restructured into a list of length 4, and then sent to the RPiSoC over i2c.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="rpisoc.Match_Clocks">
<tt class="descclassname">rpisoc.</tt><tt class="descname">Match_Clocks</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#rpisoc.Match_Clocks" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Used to identify which PWM blocks are mapped to which specific clocks. This information must be known for some higher level methods in the PWM class.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><em>val:</em></dt>
<dd>The number of clocks in the build, which is discovered from the Check_PWM() function.</dd>
</dl>
</dd>
<dt><strong>Returns:</strong></dt>
<dd><em>dat:</em> a list containing raw data for each individual clock. This data will identify which clocks are being shared, and it will provide data about each PWM&#8217;s resolution.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="rpisoc.RPiSoC">
<em class="property">class </em><tt class="descclassname">rpisoc.</tt><tt class="descname">RPiSoC</tt><a class="headerlink" href="#rpisoc.RPiSoC" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd><p class="first">This class is used to define the register locations of each component on the
RPiSoC, it defines which communication protocol will be utilized by the
API, and it collects compiled data from the RPiSoC. The class is not to be assigned to an object; it only needs to be called so
that addresses can be defined, compiled data on the RPiSoC can be verified, and so that the communication protocol can
be initialized.</p>
<p class="last">Optionally, one can construct the object with a DEBUG parameter, as described in the __new__ method description, which will print diagnostic information to the terminal.</p>
</dd>
</dl>
<dl class="staticmethod">
<dt id="rpisoc.RPiSoC.__new__">
<em class="property">static </em><tt class="descname">__new__</tt><big>(</big><em>protocol</em>, <em>DEBUG=False</em><big>)</big><a class="headerlink" href="#rpisoc.RPiSoC.__new__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Called upon construction of the class. It will decide the communication
protocol to be utilized by the API and it will attempt to learn what components are available on the RPiSoC, and some needed information about the available components.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last simple">
<li>commChannel: SPI, I2C, or COM&lt;#&gt;, as in COM1, COM2, COM3...</li>
</ul>
</dd>
<dt><strong>Optional Parameters:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>DEBUG: Defaults to False, so this parameter is optional. Changing it to True will print debugging data to the terminal.</dt>
<dd><ul class="first last simple">
<li>This data depends on the program and which classes/methods are used, but the program will at least print what information is found on the rpisoc when __new__ is called. This can be used to identify errors in your RPiSoC firmware changes.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rpisoc.SERIAL">
<em class="property">class </em><tt class="descclassname">rpisoc.</tt><tt class="descname">SERIAL</tt><big>(</big><em>com</em>, <em>baudr=9600</em><big>)</big><a class="headerlink" href="#rpisoc.SERIAL" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Provides a Serial interface for communicating with the RPiSoC through a desired COM port</dd>
<dt><strong>Description:</strong></dt>
<dd>opens the desired COM port at the specified baud, defaults to 9600 if no additional parameter is given</dd>
<dt><strong>Parameters:</strong></dt>
<dd><em>com:</em> A string representative of the desired COM port. For instance &#8216;COM16&#8217; to open COM16.</dd>
</dl>
<dl class="method">
<dt id="rpisoc.SERIAL.PrepareData">
<tt class="descname">PrepareData</tt><big>(</big><em>dat</em><big>)</big><a class="headerlink" href="#rpisoc.SERIAL.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Makes sure that the data being sent is correctly formatted, so that the RPiSoC is able to more easily decode the received words.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><em>dat:</em> A tuple of length 2 or 3</dt>
<dd><ul class="first last simple">
<li>The size of the first two items of the tuple must be less than or equal to one byte each.</li>
<li>The size of the third item in the tuple, if applicable, must be less than or equal to two bytes.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Returns:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><em>dat_l:</em> A list of length 4, prepared for SPI transfer, with the following construction:</dt>
<dd><ul class="first last simple">
<li>[dat[0], dat[1], dat[2]__LOW_BYTE, dat[2]__HIGH_BYTE]</li>
<li>The RPiSoC is expecting receipt of these 4 bytes, in this order.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="rpisoc.SERIAL.__init__">
<tt class="descname">__init__</tt><big>(</big><em>com</em>, <em>baudr=9600</em><big>)</big><a class="headerlink" href="#rpisoc.SERIAL.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>opens the desired COM port at the specified baud, defaults to 9600 if no additional parameter is given</dd>
<dt><strong>Parameters:</strong></dt>
<dd><em>com:</em> A string representative of the desired COM port. For instance &#8216;COM16&#8217; to open COM16.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="rpisoc.SERIAL.cleanup">
<tt class="descname">cleanup</tt><big>(</big><big>)</big><a class="headerlink" href="#rpisoc.SERIAL.cleanup" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Forces a software reset on the RPiSoC to clean it up, then it closes and cleans up the serial port.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="rpisoc.SERIAL.receiveData">
<tt class="descname">receiveData</tt><big>(</big><em>vals</em>, <em>delay=None</em><big>)</big><a class="headerlink" href="#rpisoc.SERIAL.receiveData" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>This function is called when a returned value from the RPiSoC is needed. It will send a command, and then wait for a response.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><em>vals:</em> A tuple which will be sent to the <em>PrepareData()</em> function to be restructured into a list of length 4, and then sent to the RPiSoC over the requested COM/Serial port.</dd>
<dt><strong>Returns:</strong></dt>
<dd><dl class="first last docutils">
<dt>The data packet received from the PSoC, which has been unpacked and reformatted.</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>Since the largest possible value that the PSoC will generally send is a 20 bit number, if a number received is sufficiently large, it will assume that the number overflowed backwards because the PSoC tried to send a negative number.</dt>
<dd><ul class="first last simple">
<li>It will account for this by subtracting (2^32 - 1) from the received data, if that data is larger than (2^24 -1)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="rpisoc.SERIAL.sendData">
<tt class="descname">sendData</tt><big>(</big><em>vals</em><big>)</big><a class="headerlink" href="#rpisoc.SERIAL.sendData" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>This function will send data to the RPiSoC, without waiting for a return</dd>
<dt><strong>Parameters:</strong></dt>
<dd><em>vals:</em> A tuple which will be sent to the <em>PrepareData()</em> function to be restructured into a list of length 4, and then sent to the rpisoc over the requested COM/Serial port.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="rpisoc.SPI">
<em class="property">class </em><tt class="descclassname">rpisoc.</tt><tt class="descname">SPI</tt><a class="headerlink" href="#rpisoc.SPI" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>This class defines usage of the SPI bus for transfer between the RPi and the PSoC. __init__ is called as soon as an <em>RPiSoC</em> object is defined, and it opens and configures the SPI bus.</dd>
<dt><strong>Note:</strong></dt>
<dd>The spidev libraries with its python wrapper must be installed to use this class.</dd>
</dl>
<dl class="method">
<dt id="rpisoc.SPI.PrepareData">
<tt class="descname">PrepareData</tt><big>(</big><em>dat</em><big>)</big><a class="headerlink" href="#rpisoc.SPI.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Makes sure that the data being sent is correctly formatted, so that the RPiSoC is able to more easily decode the received words.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><em>dat:</em> A tuple of length 2 or 3</dt>
<dd><ul class="first last simple">
<li>The size of the first two items of the tuple must be less than or equal to one byte each.</li>
<li>The size of the third item in the tuple, if applicable, must be less than or equal to two bytes.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Returns:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><em>dat_l:</em> A list of length 4, prepared for SPI transfer, with the following construction:</dt>
<dd><ul class="first last simple">
<li>[dat[0], dat[1], dat[2]__LOW_BYTE, dat[2]__HIGH_BYTE]</li>
<li>The RPiSoC is expecting receipt of these 4 bytes, in this order.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="rpisoc.SPI.cleanup">
<tt class="descname">cleanup</tt><big>(</big><big>)</big><a class="headerlink" href="#rpisoc.SPI.cleanup" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Forces a software reset on the RPiSoC and then closes and cleans up the SPI bus.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="rpisoc.SPI.receiveData">
<tt class="descname">receiveData</tt><big>(</big><em>vals</em>, <em>delay=0.01</em><big>)</big><a class="headerlink" href="#rpisoc.SPI.receiveData" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>This function is called when the RPi desires a returned value from the RPiSoC. It will send a command, and then wait for a response.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><em>vals:</em> A tuple which will be sent to the <em>PrepareData()</em> function to be restructured into a list of length 4, and then sent to the RPiSoC over SPI.</dd>
<dt><strong>Optional Parameter:</strong></dt>
<dd><em>delay:</em> The amount of time that the Python code will wait after sending a request, and before expecting a response. This is to be used when one is requesting a complex operation, and more time is needed by the RPiSoC to generate a result.</dd>
<dt><strong>Returns:</strong></dt>
<dd><dl class="first last docutils">
<dt>The data packet received from the PSoC, which has been unpacked and reformatted.</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>Since the largest possible value that the PSoC will generally send is a 20 bit number, if the RPi receives a number that is sufficiently large, it will assume that the number overflowed backwards because the PSoC tried to send a negative number.</dt>
<dd><ul class="first last simple">
<li>It will account for this by subtracting (2^32 - 1) from the received data, if that data is larger than (2^24 -1)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="rpisoc.SPI.sendData">
<tt class="descname">sendData</tt><big>(</big><em>vals</em><big>)</big><a class="headerlink" href="#rpisoc.SPI.sendData" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>This function will send data to the RPiSoC, without waiting for a return</dd>
<dt><strong>Parameters:</strong></dt>
<dd><em>vals:</em> A tuple which will be sent to the <em>PrepareData()</em> function to be restructured into a list of length 4, and then sent to the rpisoc over i2c.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="rpisoc.Test_Read">
<tt class="descclassname">rpisoc.</tt><tt class="descname">Test_Read</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#rpisoc.Test_Read" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Used to test the accuracy of data transfer between devices. It will simply echo back what is given to it as a parameter.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><em>val:</em> a 16-bit number which will be sent to the RPiSoC, and then returned.</dd>
<dt><strong>Returns:</strong></dt>
<dd><em>echo:</em> The data returned from the RPiSoC; if transmission of <em>val</em> was successful, <em>echo</em> should be equal to <em>val</em></dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-digital">
<span id="digital-py"></span><h2>digital.py<a class="headerlink" href="#module-digital" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="digital.NeoPixelShield">
<em class="property">class </em><tt class="descclassname">digital.</tt><tt class="descname">NeoPixelShield</tt><a class="headerlink" href="#digital.NeoPixelShield" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd><p class="first">This class provides functionality for use of an Arduino NeoPixels shield on an RPiSoC through Python. Create a NeoPixelShield object in the following
way:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">shield</span> <span class="o">=</span> <span class="n">NeoPixelShield</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
<p><strong>Description:</strong>
the init method defines the register address for the striplight controller used by the NeoPixels, and it defines 140 colors as class attributes, named according to their</p>
<blockquote>
<div>standardized HTML and CSS names</div></blockquote>
<dl class="method">
<dt id="digital.NeoPixelShield.Dim">
<tt class="descname">Dim</tt><big>(</big><em>DIM_LEVEL</em><big>)</big><a class="headerlink" href="#digital.NeoPixelShield.Dim" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Preserves the color to be drawn to the shield, but dims the brightness.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><em>DIM_LEVEL:</em> an integer between 0 and 4, 0 indicating full brightness, and 4 indicating full dim levelhe</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.NeoPixelShield.DrawColumn">
<tt class="descname">DrawColumn</tt><big>(</big><em>column</em>, <em>color</em><big>)</big><a class="headerlink" href="#digital.NeoPixelShield.DrawColumn" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Fully draws the chosen <em>column</em> the desired <em>color</em></dd>
<dt><strong>Parameters:</strong></dt>
<dd><p class="first"><em>column:</em> column which will be fully drawn; valid entries between 0 and 7
<em>color:</em> A 24-bit number representative of a BRG value</p>
<blockquote class="last">
<div><ul class="simple">
<li>BRG components are given equal weight, so 8-bits each.</li>
<li>There are predefined colors inside of the __init__ method, which can be called as shield.color</li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.NeoPixelShield.DrawRow">
<tt class="descname">DrawRow</tt><big>(</big><em>row</em>, <em>color</em><big>)</big><a class="headerlink" href="#digital.NeoPixelShield.DrawRow" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Fully draws the chosen <em>row</em> the desired <em>color</em></dd>
<dt><strong>Parameters:</strong></dt>
<dd><p class="first"><em>row:</em> row which will be fully drawn; valid entries between 0 and 4
<em>color:</em> A 24-bit number representative of a BRG value</p>
<blockquote class="last">
<div><ul class="simple">
<li>BRG components are given equal weight, so 8-bits each.</li>
<li>There are predefined colors inside of the __init__ method, which can be called as shield.color</li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.NeoPixelShield.SetPixel">
<tt class="descname">SetPixel</tt><big>(</big><em>row</em>, <em>column</em>, <em>color</em><big>)</big><a class="headerlink" href="#digital.NeoPixelShield.SetPixel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the given pixel at location (x,y) = (row, column), to a color defined by a 24 bit BRG value (8-bits each)</dd>
<dt><strong>Parameters:</strong></dt>
<dd><p class="first"><em>row:</em> row which contains the desired pixel to be set; valid between 0 and 4
<em>column:</em> column which contains the desired pixel to be set; valid between 0 and 7
<em>color:</em> A 24-bit number representative of a BRG value</p>
<blockquote class="last">
<div><ul class="simple">
<li>BRG components are given equal weight, so 8-bits each.</li>
<li>There are predefined colors inside of the __init__ method, which can be called as shield.color</li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.NeoPixelShield.SetPixelRGB">
<tt class="descname">SetPixelRGB</tt><big>(</big><em>row</em>, <em>column</em>, <em>RGB</em><big>)</big><a class="headerlink" href="#digital.NeoPixelShield.SetPixelRGB" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the given pixel at location (x,y) = (row, column), to a color defined by its RGB values independently</dd>
<dt><strong>Parameters:</strong></dt>
<dd><p class="first"><em>row:</em> row which contains the desired pixel to be set; valid between 0 and 4
<em>column:</em> column which contains the desired pixel to be set; valid between 0 and 7
<em>RGB:</em> A list or tuple, describing the RGB construction of the color</p>
<blockquote class="last">
<div><ul class="simple">
<li>The first element will contain a number between 0 and 255, corresponding to the red byte</li>
<li>The second element will contain a number between 0 and 255, corresponding to the blue byte</li>
<li>The third element will contain a number between 0 and 255, corresponding to the green byte</li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.NeoPixelShield.Start">
<tt class="descname">Start</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.NeoPixelShield.Start" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Powers up and enables the needed hardware for the NeoPixels component</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.NeoPixelShield.Stop">
<tt class="descname">Stop</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.NeoPixelShield.Stop" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Powers down and disables the hardware used by the NeoPixels component</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.NeoPixelShield.Stripe">
<tt class="descname">Stripe</tt><big>(</big><em>pixelnum</em>, <em>color</em><big>)</big><a class="headerlink" href="#digital.NeoPixelShield.Stripe" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Draws a line of length <em>pixelnum</em> of the stated <em>color</em>, starting from the first pixel, and extending as far as the 40th
(last) pixel. It will wrap around rows</dd>
<dt><strong>Parameters:</strong></dt>
<dd><p class="first"><em>pixelnum:</em> A number between 1 and 40, which indicates how many pixels, starting with pixel (0,0), will be filled.
<em>color:</em> A 24-bit number representative of a BRG value</p>
<blockquote class="last">
<div><ul class="simple">
<li>BRG components are given equal weight, so 8-bits each.</li>
<li>There are predefined colors inside of the __init__ method, which can be called as shield.color</li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="digital.PWM">
<em class="property">class </em><tt class="descclassname">digital.</tt><tt class="descname">PWM</tt><big>(</big><em>portNumber</em><big>)</big><a class="headerlink" href="#digital.PWM" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd><p class="first">This class provides functionality for use of the PWM components available on the RPiSoC. Define PWM objects in the following
way:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">My_PWM</span>       <span class="o">=</span> <span class="n">PWM</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">My_other_PWM</span> <span class="o">=</span> <span class="n">PWM</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="sd">&#39;&#39;&#39;etc etc...    &#39;&#39;&#39;</span>
<span class="n">My_last_PWM</span>  <span class="o">=</span> <span class="n">PWM</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<p><strong>Parameters:</strong></p>
<ul>
<li><dl class="first docutils">
<dt><em>portNumber:</em> Valid inputs are 0-(N-1), assuming that there are N PWM channels in your RPiSoC schematic (8 by default).</dt>
<dd><ul class="first last simple">
<li>For the default version of V1.2/4, this number corresponds to the respective pin on Port 6 for channels 1-7, and P0[2] for PWM(0)</li>
</ul>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="digital.PWM.ClearFIFO">
<tt class="descname">ClearFIFO</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.PWM.ClearFIFO" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Clears the capture FIFO of any previously captured data. Here PWM_ReadCapture() is called until the FIFO is empty.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.GetClockDivider">
<tt class="descname">GetClockDivider</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.PWM.GetClockDivider" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Gets the most recently confirmed clock divider value, which is used to determine the clocking frequency of the PWM.</dd>
<dt><strong>Returns:</strong></dt>
<dd>16-bit clock divider value</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.GetClocks">
<tt class="descname">GetClocks</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.PWM.GetClocks" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Calculates the actual clock rate of the PWM&#8217;s based on the most recently confirmed clock divider value.</dd>
<dt><strong>Returns:</strong></dt>
<dd>The actual frequency of the PWM clock</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.GetDutyCycle">
<tt class="descname">GetDutyCycle</tt><big>(</big><em>PRECISION=2</em><big>)</big><a class="headerlink" href="#digital.PWM.GetDutyCycle" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Calculates the current duty cycle based on the current period and comparison values.</dd>
<dt><strong>Returns:</strong></dt>
<dd>A float value which is representative of the percentage of time, between 0 and 100%, that the PWM signal is
on, relative to the total length of its period.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.GetFrequency">
<tt class="descname">GetFrequency</tt><big>(</big><em>PRECISION=2</em><big>)</big><a class="headerlink" href="#digital.PWM.GetFrequency" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Calculates the current PWM wave frequency based on the current clock rate and period value</dd>
<dt><strong>Returns:</strong></dt>
<dd>A frequency in Hz, which is representative of the current PWM signal frequency.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.ReadCompare">
<tt class="descname">ReadCompare</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.PWM.ReadCompare" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Returns the current comparison value (in <em>counts</em>) of the PWM block</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.ReadPeriod">
<tt class="descname">ReadPeriod</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.PWM.ReadPeriod" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Returns the current period value (in counts) of the PWM block</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.SetClockDivider">
<tt class="descname">SetClockDivider</tt><big>(</big><em>divider</em><big>)</big><a class="headerlink" href="#digital.PWM.SetClockDivider" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>This method will set a divider to the desired PWM&#8217;s clock.</dd>
</dl>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><em>divider:</em> An integer between <em>0</em> and <em>65535</em> which the PWM clock will be divided by</dt>
<dd><ul class="first last simple">
<li>Changing the clock&#8217;s divider, and consequently its frequency, will affect any other PWMs which share that clock.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.SetClocks">
<tt class="descname">SetClocks</tt><big>(</big><em>frequency</em><big>)</big><a class="headerlink" href="#digital.PWM.SetClocks" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Attempts to set the PWM Clock rate to a desired frequency using an appropriate clock divider.
It will wait for a response from the RPiSoC which represents the actual clock divider which was set.
This value is then saved in the RPiSoC class so that it can be referenced to calculate the actual clock frequency at request.</dd>
</dl>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><em>frequency:</em> A frequency in Hz which represents the desired clock rate</dt>
<dd><ul class="first last simple">
<li>This is NOT the frequency of the PWM, it is the frequency of the clock which drives it</li>
<li>Changing the clock frequency for any single PWM will change it for all PWM&#8217;s since they share the same clock</li>
<li>This value cannot be less than <em>367</em> Hz and cannot be more than 24 MHz (<em>24000000</em> Hz)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt><strong>Warning:</strong></dt>
<dd><ul class="first last">
<li><p class="first">At frequencies higher than 2.526 MHz (<em>2526318</em> Hz) accuracy <em>cannot</em> be guaranteed to be within a tolerance of 5%</p>
</li>
<li><dl class="first docutils">
<dt>At frequencies higher than 5.333 MHz (<em>5333345</em> Hz) accuracy <em>cannot</em> be guaranteed to be within a tolerance of 10%</dt>
<dd><ul class="first last simple">
<li>The frequency might still be accurate at high frequencies; those tolerances are worst case scenarios. Use <em>GetClocks()</em> to get the actually achieved frequency.</li>
<li>These numbers are valid only for a 24MHz driving frequency, which is the suggested rate for PWM.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.SetDutyCycle">
<tt class="descname">SetDutyCycle</tt><big>(</big><em>duty_cycle</em><big>)</big><a class="headerlink" href="#digital.PWM.SetDutyCycle" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Simplifies the process of setting a meaningful comparison value by calculating the correct cmp value based on a desired duty cycle.</dd>
</dl>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><em>duty_cycle:</em> a number between 0 and 100 which indicates the percentage of time that the PWM should be HIGH during one period.</dt>
<dd><ul class="first last simple">
<li>A duty_cycle of 100 indicates that the PWM is always on,</li>
<li>A duty_cycle of 50 indicates that the PWM is on half of the time</li>
<li>A duty_cycle of 0 indicates that the PWM is always off.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.SetFrequency">
<tt class="descname">SetFrequency</tt><big>(</big><em>freq</em>, <em>MAX_ERROR=5</em>, <em>MIN_PERIOD=10</em><big>)</big><a class="headerlink" href="#digital.PWM.SetFrequency" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Attempts to set the PWM wave frequency to a desired rate by calculating an appropriate period value and/or clock rate
It will try to maintain the clock rate, unless it is impossible without compromising the duty cycle to severely.</dd>
</dl>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><em>freq:</em> A frequency in Hz which represents the desired wave rate</dt>
<dd><ul class="first last simple">
<li>This is NOT the frequency of the clock which drive the PWM, it is the actual output frequency</li>
<li>If the frequency cannot be reached without changing the clock rate, any PWM&#8217;s sharing that clock will be affected</li>
<li>This value cannot be less than .006 Hz and cannot be more than 2.4 MHz (<em>2400000</em> Hz)</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.Sleep">
<tt class="descname">Sleep</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.PWM.Sleep" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Stops the PWM operation and saves the current configuration</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.Start">
<tt class="descname">Start</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.PWM.Start" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Starts component operation. Sets the initVar variable, calls the PWM_Init function, and then calls the PWM_Enable function.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.Stop">
<tt class="descname">Stop</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.PWM.Stop" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Disables the PWM operation</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.Wakeup">
<tt class="descname">Wakeup</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.PWM.Wakeup" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Restores and enables the most recently saved configuration.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.WriteCompare">
<tt class="descname">WriteCompare</tt><big>(</big><em>cmp</em><big>)</big><a class="headerlink" href="#digital.PWM.WriteCompare" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Writes the 16-bit compare value for the PWM output</dd>
</dl>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><em>cmp:</em> An integer value, in <em>counts</em>, which determines how long during a PWM cycle that the output is HIGH.</dt>
<dd><ul class="first last simple">
<li>The value must not be greater than <strong>65535</strong> (for 16-bit mode, which is the default)</li>
<li>For 8-bit mode it must not be greater than <strong>255</strong></li>
<li>The comparison value must also be less than or equal to the period</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="digital.PWM.WritePeriod">
<tt class="descname">WritePeriod</tt><big>(</big><em>period</em><big>)</big><a class="headerlink" href="#digital.PWM.WritePeriod" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Writes the period value used by the PWM hardware.</dd>
</dl>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>period: The length, in <em>counts</em>, which defines how long a PWM Cycle will be</dt>
<dd><ul class="first last simple">
<li>The value must not be greater than <strong>65535</strong> (for 16-bit mode, which is the default)</li>
<li>for 8-bit mode it must not be greater than <strong>255</strong></li>
<li>The period must be greater than the comparison value</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="digital.Servo">
<em class="property">class </em><tt class="descclassname">digital.</tt><tt class="descname">Servo</tt><big>(</big><em>servo_id</em>, <em>min_pulse=1.0</em>, <em>max_pulse=2.0</em>, <em>min_angle=0</em>, <em>max_angle=180</em><big>)</big><a class="headerlink" href="#digital.Servo" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd><p class="first">Creates a servo object with the given parameter set. Define PWM objects in any the following
ways:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">My_simple_servo</span>       <span class="o">=</span> <span class="n">Servo</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">My_calibrated_servo</span>   <span class="o">=</span> <span class="n">Servo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="n">My_descriptive_servo</span>  <span class="o">=</span> <span class="n">Servo</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">180</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul class="simple">
<li><em>servo_id:</em> the pin which the servo will be connected to, relative to port 6 on the RPiSoC</li>
</ul>
</div></blockquote>
<p><strong>Optional Parameters:</strong></p>
<blockquote>
<div><ul>
<li><p class="first"><em>min_pulse:</em> the pulse width necessary to obtain angular position min_angle. Find an appropriate value through calibration; it defaults to 1.0</p>
</li>
<li><dl class="first docutils">
<dt><em>max_pulse:</em> the pulse width necessary to obtain angular position max_angle. Find an appropriate value through calibration; it defaults to 2.0</dt>
<dd><ul class="first last simple">
<li>Pulse widths must be positive and greater than zero.</li>
<li>Pulse width values are usually have maximum values of 2 to 2.3 and minimum values of 0.8 to 1.2</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first"><em>min_angle:</em> the angle which the servo will return to if applied with a pulse width of min_pulse. Defaults to 0</p>
</li>
<li><dl class="first docutils">
<dt><em>max_angle:</em> the angle which the servo will return to if applied with a pulse width of max_pulse. Defaults to 180</dt>
<dd><ul class="first last simple">
<li>Negative angular positions are valid. Angles can be any angular unit: degrees, radians, or other arbitrary (linear) scale</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt><strong>Note:</strong></dt>
<dd>A servo with servo_id, n, will make PWM(n) unnavailable, since the servo controller is implemented using that PWM object. For fine control over
that PWM, you can expose the object using My_servo.servo_PWM, and then you can use any of the PWM methods using My_servo.servo_PWM.method(). This is
advised against though, because servos are very particular about the construction of their data signals. If you change the wrong parameter of the PWM signal, you
might damage the servo.</dd>
</dl>
<dl class="method">
<dt id="digital.Servo.ReadAngle">
<tt class="descname">ReadAngle</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.Servo.ReadAngle" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Calculates the current angle of the servomotor, linearized relative to the provided maximum and minimum angles.</dd>
<dt><strong>Returns:</strong></dt>
<dd>An angle between the minimum and maximum angles provided, representative of the angle that the servo motor should be held at, according to the provided scale.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.Servo.ReadPulse">
<tt class="descname">ReadPulse</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.Servo.ReadPulse" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Calculates the current pulse width of the PWM which is driving the servomotor</dd>
<dt><strong>Returns:</strong></dt>
<dd>A pulse width in milliseconds, representative of the pulse being applied ot the servomotor</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.Servo.SetAngle">
<tt class="descname">SetAngle</tt><big>(</big><em>angle</em><big>)</big><a class="headerlink" href="#digital.Servo.SetAngle" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Calculates a pulse width based on the given angular position and the min/max
configuration parameters defined at initialization, then calls SetPulse to
set the position of the servo.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><em>angle:</em> The angle to which the servo should be set, linearized relative to the defined minimum and maximum angles.</dt>
<dd><ul class="first last simple">
<li>Negative angular positions are valid. Angles can be any angular unit: degrees, radians, or other arbitrary (linear) scale but they must be within the same scale used when initializing the min/max configuration parameters.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.Servo.SetPulse">
<tt class="descname">SetPulse</tt><big>(</big><em>pulse_ms</em><big>)</big><a class="headerlink" href="#digital.Servo.SetPulse" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets a servo position based on a pulse width in ms.</dd>
</dl>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul class="simple">
<li><em>pulse_ms:</em> a pulse width in ms, which will be applied to the servo.Normal values are between 0.8 and 2.3</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="digital.Servo.Start">
<tt class="descname">Start</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.Servo.Start" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Starts the servo object so that it can be used.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.Servo.Stop">
<tt class="descname">Stop</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.Servo.Stop" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Stops the servo object by terminating the PWM channel that drives it.</dd>
<dt><strong>Side Effects:</strong></dt>
<dd>This may cause the servo to move slightly out of position</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="digital.digitalPin">
<em class="property">class </em><tt class="descclassname">digital.</tt><tt class="descname">digitalPin</tt><big>(</big><em>PORT</em>, <em>PIN</em>, <em>CONFIG</em><big>)</big><a class="headerlink" href="#digital.digitalPin" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd><p class="first">Provides functionality for use of the GPIO on the RPiSoC as a digital input or output, with a number of different drive mode configurations. Define a digitalPin object in the following
way:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">My_input</span> <span class="o">=</span> <span class="n">digitalPin</span><span class="p">(</span><span class="n">Port</span><span class="p">,</span><span class="n">Pin</span><span class="p">,</span><span class="s">&#39;IN&#39;</span><span class="p">)</span>
<span class="n">My_output</span> <span class="o">=</span> <span class="n">digitalPin</span><span class="p">(</span><span class="n">Port</span><span class="p">,</span><span class="n">Pin</span><span class="p">,</span><span class="s">&#39;OUT&#39;</span><span class="p">)</span>
<span class="sd">&#39;&#39;&#39;or more generally&#39;&#39;&#39;</span>
<span class="n">My_pin</span> <span class="o">=</span> <span class="n">digitalPin</span><span class="p">(</span><span class="n">Port</span><span class="p">,</span><span class="n">Pin</span><span class="p">,</span><span class="n">DRIVE_MODE</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><em>PORT</em>: Port on the RPiSoC.</dt>
<dd><ul class="first last simple">
<li>GPIO Ports are chosen by default as Ports <em>2, 5</em> and <em>12.</em> for V1.2, but they are easily changed</li>
<li>Port <em>4</em> does not contain Pin <em>7</em> (it is reserved)</li>
<li>Port 5 uses 3.3V logic instead of 5V.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>PIN</em>: Pin relative to the chosen Port.</dt>
<dd><ul class="first last simple">
<li>Valid arguments are between <em>0</em> and <em>7</em>, unless noted to have a Port specific exception, or if that pin is removed from your RPiSoC schematic.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><em>CONFIG:</em> drive mode of the pin. Valid choices are:</dt>
<dd><ul class="first last simple">
<li>&#8216;IN&#8217; - sets pin as input</li>
<li>&#8216;OUT&#8217; - sets pin as output</li>
<li>&#8216;PULL_UP&#8217; - sets pin as resisitive pullup</li>
<li>&#8216;PULL_DWN&#8217; - sets pin as resistive pulldown</li>
<li>&#8216;OPEN_DRAIN_LO&#8217; - sets pin as open-drain (drives low)</li>
<li>&#8216;OPEN_DRAIN_HI&#8217; - sets pin as open-drain (drives high)</li>
<li>&#8216;PULL_UP_DWN&#8217; - sets pin as resistive pull-up/down</li>
<li>&#8216;HIGH_Z_DIG&#8217; - sets pin as high impedence (digital)</li>
<li>&#8216;STRONG_DRIVE&#8217; - sets pin as strong drive</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt><strong>Note:</strong></dt>
<dd>Modification of which pins are available should be easy. Just add new pins to you RPiSoC schematic, give them an input and an output, and then name them as GPIO_PORT_PIN.
After you do this, confirm that it was done correctly by using the DEBUG feature of the RPiSoC class.</dd>
</dl>
<dl class="method">
<dt id="digital.digitalPin.Configure">
<tt class="descname">Configure</tt><big>(</big><em>CONFIG</em><big>)</big><a class="headerlink" href="#digital.digitalPin.Configure" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the drive mode of the pin as input (high impedence digital), resistive pullup, resistive pull down, open drain (drives low), open drain (drives high), output (strong drive), or resistive pull-up/down</dd>
</dl>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><em>CONFIG:</em> drive mode of the pin. Valid choices are:</dt>
<dd><ul class="first last simple">
<li>&#8216;IN&#8217; - sets pin as input</li>
<li>&#8216;OUT&#8217; - sets pin as output</li>
<li>&#8216;PULL_UP&#8217; - sets pin as resisitive pullup</li>
<li>&#8216;PULL_DWN&#8217; - sets pin as resistive pulldown</li>
<li>&#8216;OPEN_DRAIN_LO&#8217; - sets pin as open-drain (drives low)</li>
<li>&#8216;OPEN_DRAIN_HI&#8217; - sets pin as open-drain (drives high)</li>
<li>&#8216;PULL_UP_DWN&#8217; - sets pin as resistive pull-up/down</li>
<li>&#8216;HIGH_Z_DIG&#8217; - sets pin as high impedence (digital)</li>
<li>&#8216;STRONG_DRIVE&#8217; - sets pin as strong drive</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="digital.digitalPin.Read">
<tt class="descname">Read</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.digitalPin.Read" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Returns a boolean value (True/False) which correlates to the current state of the input.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.digitalPin.Toggle">
<tt class="descname">Toggle</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.digitalPin.Toggle" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Toggles the state of the specified output and then writes the new value to the RPiSoC.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.digitalPin.Write">
<tt class="descname">Write</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#digital.digitalPin.Write" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd><ul class="first last">
<li><p class="first">Writes a new value to the output port, without affecting the other pins attached to that port.</p>
</li>
<li><dl class="first docutils">
<dt>Before committing the write operation, this function will confirm that the new value is different than the previous value.</dt>
<dd><ul class="first last simple">
<li>If it is not different, meaning the output is already the correct value, it will not do anything.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><em>val:</em> Value to be written to the initialized Pin object.</dt>
<dd><ul class="first last simple">
<li>Accepts only <em>1</em> or <em>0</em> for writing the output HIGH or LOW, respectively.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="digital.rangeFinder">
<em class="property">class </em><tt class="descclassname">digital.</tt><tt class="descname">rangeFinder</tt><big>(</big><em>SIG</em>, <em>TRIGGER=None</em>, <em>DELAYus=10</em>, <em>TIMEOUTus=30000</em><big>)</big><a class="headerlink" href="#digital.rangeFinder" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>This class provides functionality for use of ultrasonic range finder devices that use standard GPIO pulse width measurement protocols.</dd>
<dt><strong>Description:</strong></dt>
<dd>Initialize an object by telling it what pin the echo time will be measured on. Optionally, provide a trigger pin if the ranger is a 4 or 5 pin form factor,
also optionally provide a trigger pulse width and timeout value in milliseconds</dd>
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><em>SIG:</em> A list constructed as <em>[PORT, PIN]</em> which defines which exact pin will be used to communicate with the rangers signal/echo pin</dt>
<dd><ul class="first last simple">
<li>PORT is the port on the RPiSoC connected to the rangers signal pin</li>
<li>PIN is the pin relative to that port</li>
</ul>
</dd>
<dt><em>TRIGGER:</em> A list constructed as <em>[PORT, PIN]</em> which defines which exact pin will be used to communicate with the rangers trigger pin</dt>
<dd><ul class="first last simple">
<li>By default, if no argument is provided, it will assume the trigger pin is the same as the echo pin; this is true for 3-pin devices and so no argument is needed</li>
<li>PORT is the port on the RPiSoC connected to the rangers trigger pin</li>
<li>PIN is the pin relative to that port</li>
</ul>
</dd>
<dt><em>DELAYus:</em> The width of the trigger pulse, in microseconds, that will be sent from the TRIGGER pin, to signal the ranger to send a ping</dt>
<dd><ul class="first last simple">
<li>This defaults as 10 microseconds, but most rangers are okay with much less.</li>
</ul>
</dd>
<dt><em>TIMEOUTus:</em> The maximum length of time, in microseconds, that the RPiSoC will wait for a confirmed echo.</dt>
<dd><ul class="first last">
<li><p class="first">If this time is exceeded, the ranger will immediately terminate its timing process and return the timeout as a response</p>
</li>
<li><dl class="first docutils">
<dt>This defaults as 30000 microseconds, which is equivalent to 30 ms, and is much longer than generally needed and so won&#8217;t usually need to be altered.</dt>
<dd><ul class="first last simple">
<li>Refer to your devices documentation for a more specific timeout choice</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="digital.rangeFinder.readCentimeters">
<tt class="descname">readCentimeters</tt><big>(</big><em>sound=340.29</em>, <em>PRECISION=2</em><big>)</big><a class="headerlink" href="#digital.rangeFinder.readCentimeters" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Uses readRaw to get a raw time value in microseconds, and then calculates the distance between the ranger and the pinged object in centimeters</dd>
<dt><strong>Optional Parameters:</strong></dt>
<dd><dl class="first docutils">
<dt><em>sound:</em> The speed of sound which is used to calcuate the distance of the object detected by the ranger.</dt>
<dd><ul class="first last simple">
<li>Defaults to 343 m/s (approximate value based on room temperature of air)</li>
<li>Must be m/s</li>
<li>Modify this according to your environmental needs (different temperature/medium)</li>
</ul>
</dd>
</dl>
<p class="last"><em>PRECISION:</em> The number of decimal points to be included in the returned result. Defualts to 2</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.rangeFinder.readInches">
<tt class="descname">readInches</tt><big>(</big><em>sound=340.29</em>, <em>PRECISION=2</em><big>)</big><a class="headerlink" href="#digital.rangeFinder.readInches" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Uses readRaw to get a raw time value in microseconds, and then calculates the distance between the ranger and the pinged object in inches</dd>
<dt><strong>Optional Parameters:</strong></dt>
<dd><dl class="first docutils">
<dt><em>sound:</em> The speed of sound which is used to calcuate the distance of the object detected by the ranger.</dt>
<dd><ul class="first last simple">
<li>Defaults to 343 m/s (approximate value based on room temperature of air)</li>
<li>Must be m/s</li>
<li>Modify this according to your environmental needs (different temperature/medium)</li>
</ul>
</dd>
</dl>
<p class="last"><em>PRECISION:</em> The number of decimal points to be included in the returned result. Defualts to 2</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.rangeFinder.readMeters">
<tt class="descname">readMeters</tt><big>(</big><em>sound=343.0</em>, <em>PRECISION=2</em><big>)</big><a class="headerlink" href="#digital.rangeFinder.readMeters" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Uses readRaw to get a raw time value in microseconds, and then calculates the distance between the ranger and the pinged object in meters</dd>
<dt><strong>Optional Parameters:</strong></dt>
<dd><dl class="first docutils">
<dt><em>sound:</em> The speed of sound which is used to calcuate the distance of the object detected by the ranger.</dt>
<dd><ul class="first last simple">
<li>Defaults to 343 m/s (approximate value based on room temperature of air)</li>
<li>Must be m/s</li>
<li>Modify this according to your environmental needs (different temperature/medium)</li>
</ul>
</dd>
</dl>
<p class="last"><em>PRECISION:</em> The number of decimal points to be included in the returned result. Defualts to 2</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.rangeFinder.readRaw">
<tt class="descname">readRaw</tt><big>(</big><big>)</big><a class="headerlink" href="#digital.rangeFinder.readRaw" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Description:</strong>
gets a raw value from the RPiSoC, which is representative of how many microseconds the
rangers echo pin was held high. It will trigger the range by sending a short pulse, the length defined upon construction of the object.
The result will be measured on the desired signal pin, and stop measuring when a timeout is reached</p>
</dd></dl>

<dl class="method">
<dt id="digital.rangeFinder.setDelay">
<tt class="descname">setDelay</tt><big>(</big><em>delay_us</em><big>)</big><a class="headerlink" href="#digital.rangeFinder.setDelay" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the length of the trigger pulse, in microseconds, which will be used to tell the device to send out a ping.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><em>delay_us:</em> Amount of time, in microseconds, that the RPiSoC will hold its trigger pulse high</dt>
<dd><ul class="first last simple">
<li>This is a bit limited value (6-bits maximum), and so it cannot exceed 63, nor can it be below 0</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>Notes:</strong></dt>
<dd>This is handled in __init__, so it should only be called under unique circumstances</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="digital.rangeFinder.setTimeout">
<tt class="descname">setTimeout</tt><big>(</big><em>timeout_us</em><big>)</big><a class="headerlink" href="#digital.rangeFinder.setTimeout" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Description:</strong>
Sets the timeout length in microseconds. If the RPiSoC is still waiting for a completed response after this amount of time, it
will stop counting and immediately return the result</p>
<dl class="docutils">
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><em>timeout_us:</em> Amount of time, in microseconds, that the RPiSoC will wait for a completed response.</dt>
<dd><ul class="first last simple">
<li>This is a 16 bit value, and so it cannot exceed 65535, nor can it be below 0</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>Notes:</strong></dt>
<dd>This is handled in __init__, so it should only be called under unique circumstances</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-analog">
<span id="analog-py"></span><h2>analog.py<a class="headerlink" href="#module-analog" title="Permalink to this headline">¶</a></h2>
<p>This module defines the usage for the analog functionality
of the RPiSoC.</p>
<dl class="class">
<dt id="analog.ADC">
<em class="property">class </em><tt class="descclassname">analog.</tt><tt class="descname">ADC</tt><big>(</big><em>c_type</em><big>)</big><a class="headerlink" href="#analog.ADC" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd><p class="first">The ADC class provides functionality for using the Delta Sigma ADC and two
Succesive Approximation ADC&#8217;s on the RPiSoC. Define ADC objects in the following
way:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">My_DELSIG</span>    <span class="o">=</span> <span class="n">ADC</span><span class="p">(</span><span class="s">&#39;DELSIG&#39;</span><span class="p">)</span>
<span class="n">My_SAR</span>       <span class="o">=</span> <span class="n">ADC</span><span class="p">(</span><span class="s">&#39;SAR0&#39;</span><span class="p">)</span>
<span class="n">My_other_SAR</span> <span class="o">=</span> <span class="n">ADC</span><span class="p">(</span><span class="s">&#39;SAR1&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt><strong>Paramaters:</strong></dt>
<dd><dl class="first last docutils">
<dt><em>c_type:</em> The type of ADC to be used. Choose:</dt>
<dd><ul class="first last simple">
<li><em>DELSIG</em></li>
<li><em>SAR0</em></li>
<li><em>SAR1</em></li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>Note:</strong></dt>
<dd>None of the ADCs are included by default in V1.2. You are able to add them by simply placing them in your schematic on your RPiSoC program.</dd>
</dl>
<dl class="method">
<dt id="analog.ADC.CountsTo_Volts">
<tt class="descname">CountsTo_Volts</tt><big>(</big><em>counts</em><big>)</big><a class="headerlink" href="#analog.ADC.CountsTo_Volts" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Converts the ADC output to a Voltage.</dd>
<dt><strong>Returns:</strong></dt>
<dd>A float which represents the converted count number in Volts.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.ADC.GetResult">
<tt class="descname">GetResult</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.ADC.GetResult" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>This function will get the result of a conversion which has been completed. <em>StartConvert()</em> must be called prior to this function, and <em>StopConvert()</em> must be called after.</dd>
<dt><strong>Returns:</strong></dt>
<dd>Value in <em>counts</em> of the most recent A/D conversion.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.ADC.IsEndConversion">
<tt class="descname">IsEndConversion</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.ADC.IsEndConversion" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>This function checks to see if the ADC is done converting.</dd>
<dt><strong>Returns:</strong></dt>
<dd><ul class="first last simple">
<li>The value of the most recent conversion, if it is complete.</li>
<li><em>0</em> if the conversion is not complete</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.ADC.Read">
<tt class="descname">Read</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.ADC.Read" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>This function simplifies the reading process by starting conversion, waiting for conversion to complete, stopping conversion, and returing the result, when called. It is only valid for the <em>DELSIG</em></dd>
<dt><strong>Returns:</strong></dt>
<dd>Value in <em>counts</em> of the most recent A/D conversion.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.ADC.SetBufferGain">
<tt class="descname">SetBufferGain</tt><big>(</big><em>gain</em><big>)</big><a class="headerlink" href="#analog.ADC.SetBufferGain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the input buffer gain.</dd>
<dt><strong>Paramaters:</strong></dt>
<dd><ul class="first last simple">
<li><em>gain:</em> valid entries are <em>1, 2, 4,</em> or <em>8.</em> The output will be multiplied by this number</li>
</ul>
</dd>
</dl>
<p><strong>Side effects:</strong> Increasing the gain will lower the buffer bandwidth</p>
</dd></dl>

<dl class="method">
<dt id="analog.ADC.SetGain">
<tt class="descname">SetGain</tt><big>(</big><em>gain</em><big>)</big><a class="headerlink" href="#analog.ADC.SetGain" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the ADC <em>gain</em> in counts per volt for the <em>CountsTo_Volts()</em> function.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last simple">
<li><em>gain:</em> Output gain in counts per volt to be applied before conversion.</li>
</ul>
</dd>
<dt><strong>Warning:</strong></dt>
<dd><em>gain</em> is set by default by the reference and input range settings. It should only be used to further calibrate the ADC with a known input or if an external reference is used.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.ADC.SetOffset">
<tt class="descname">SetOffset</tt><big>(</big><em>offset</em><big>)</big><a class="headerlink" href="#analog.ADC.SetOffset" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets an offset on the ADC which is used by the CountsTo_Volts function. It will subtract the given offset before making the conversion.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last simple">
<li><em>offset</em>: ADC Value in <em>counts</em>, which will be used by the <em>CountsTo_Volts()</em> function by subtracting the given offset before making the conversion.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.ADC.SetResolution">
<tt class="descname">SetResolution</tt><big>(</big><em>resolution</em><big>)</big><a class="headerlink" href="#analog.ADC.SetResolution" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd><ul class="first last simple">
<li>This function sets the resolution of the SAR ADC&#8217;s</li>
<li><em>SetResolution()</em> is <strong>not</strong> valid for the DELSIG ADC, which is defaulted to 16 bits resolution.</li>
</ul>
</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><em>resolution:</em> An integer value, in bits, that represents the new resolution of the SAR ADC.</dt>
<dd><ul class="first last simple">
<li>Valid entries are <em>8, 10, or 12.</em></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Side Effects:</strong></dt>
<dd><ul class="first last simple">
<li>The ADC resolution cannot be changed during a conversion cycle. The recommended bestpractice is to stop conversions with <em>StopConvert(),</em> change the resolution, then restart the conversions with <em>StartConvert().</em> If you decide not to stop conversions before calling this API, use <em>IsEndConversion()</em> to wait until conversion is complete before changing the resolution. If you call <em>SetResolution()</em> during a conversion, the resolution will not change until the current conversion is complete. Data will not be available in the new resolution for another 6 + <em>resolution</em> clock cycles. You may need add a delay of this number of clock cycles after <em>SetResolution()</em> is called before data is valid again.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.ADC.Sleep">
<tt class="descname">Sleep</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.ADC.Sleep" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>The ADC Sleep function checks to see if the component is enabled, then it stops the ADC and saves the current configuration for later use.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.ADC.Start">
<tt class="descname">Start</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.ADC.Start" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the initVar variable on the RPiSoC, calls the ADC_Init() function, and then calls the ADC_Enable() function. This function configures and powers up the ADC, but does not start conversions.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.ADC.StartConvert">
<tt class="descname">StartConvert</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.ADC.StartConvert" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Forces the ADC to initialize a conversion. This is handled internally for the Delsig ADC, using the <em>Read()</em> function, but it is kept seperate for the SAR. It can be done seperately for the Delsig as well, if desired.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.ADC.Stop">
<tt class="descname">Stop</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.ADC.Stop" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Disables and powers down the ADC</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.ADC.StopConvert">
<tt class="descname">StopConvert</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.ADC.StopConvert" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Forces the ADC to end conversion. This is handled internally for the Delsig ADC, using the <em>Read()</em> function, but it is kept seperate for the SAR. It can be done seperately for the DELSIG as well, if desired.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.ADC.Wakeup">
<tt class="descname">Wakeup</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.ADC.Wakeup" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>The ADC Wakeup function restores the most recently saved ADC configuration so that it can be restarted.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="analog.CapSense">
<em class="property">class </em><tt class="descclassname">analog.</tt><tt class="descname">CapSense</tt><big>(</big><em>PIN</em>, <em>THRESHOLD=0</em><big>)</big><a class="headerlink" href="#analog.CapSense" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Description:</strong>
Provides functionality for use of CapSense buttons on the RPiSoC. Define a CapSense object in the following
way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">My_capsense_button</span> <span class="o">=</span> <span class="n">CapSense</span><span class="p">(</span><span class="n">PIN</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Parameters:</strong></p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><em>PIN</em>: The capsense pin number. PIN n directly corresponds to the pin which you assign to Capsense_BTN_N in your rpisoc firmware</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>The following is valid for the default version of the API (v1.2) which contains 6 capsense buttons</dt>
<dd><ul class="first last simple">
<li>The Cmod pin, which should be a 2.2nF capacitor, should be connected between ground and P4[6]</li>
<li>PIN is the number relative to Port 4, between <em>0</em> and <em>5</em>.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p><strong>Optional Parameters:</strong></p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><em>THRESHOLD</em>: The number of counts, between 0 and 255, which will be added to your calibrated baseline value to determine if a button has been touched.</dt>
<dd><ul class="first last simple">
<li><em>0</em> means that the baseline value itself will be used as a comparison value. Generally, baseline + THRESHOLD is used</li>
<li>The threshold may need to be high if the button data is noisy. Try printing the results of <em>readRaw()</em> to get an understanding of the output behavior as you touch the button, this will help determine a suitable value</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="analog.CapSense.Read">
<tt class="descname">Read</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.CapSense.Read" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Gives the state of the capsense button, as determined by the PSoC firmware. This will need to be calibrated in the CapSense component for optimal results. Use isTouched for more general application.</dd>
<dt><strong>Returns:</strong></dt>
<dd>state: bool which represents the current state of the capsense button.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.CapSense.Sleep">
<tt class="descname">Sleep</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.CapSense.Sleep" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Prepares the component for the device entering a low-power mode. Disables Active mode power template bits of the sub components used within CapSense, saves nonretention registers, and resets all sensors to an inactive state.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.CapSense.Start">
<tt class="descname">Start</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.CapSense.Start" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Initializes registers and enables active mode power template bits of the subcomponents used within CapSense. It also attempts to establish a CapSense baseline, which will be used as a comparison value in the <em>isTouched()</em> method.
The button should not be touched when this method is called, otherwise the baseline value will be calibrated with a touched value. It will only set the baseline if it sees two identical readings in a row.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.CapSense.Stop">
<tt class="descname">Stop</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.CapSense.Stop" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Disables component interrupts, and calls CapSense_ClearSensors() to reset all sensors to an inactive state.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.CapSense.Wakeup">
<tt class="descname">Wakeup</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.CapSense.Wakeup" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Restores CapSense configuration and nonretention register values after the device wake from a low power mode sleep mode.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.CapSense.isTouched">
<tt class="descname">isTouched</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.CapSense.isTouched" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Uses the calibrated baseline and provided threshold value to determine if the requested CapSense button is being touched</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.CapSense.readRaw">
<tt class="descname">readRaw</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.CapSense.readRaw" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Gives an 8-bit raw value from the capsense raw data array. This is used to generate a baseline in <em>Start()</em></dd>
<dt><strong>Returns:</strong></dt>
<dd>val: int which represents the raw value on the capsense button</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="analog.IDAC">
<em class="property">class </em><tt class="descclassname">analog.</tt><tt class="descname">IDAC</tt><big>(</big><em>channel</em><big>)</big><a class="headerlink" href="#analog.IDAC" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd><p class="first">The IDAC class provides functionality for using the IDAC&#8217;s available on the RPiSoC. Define IDAC objects in the following
way:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">My_IDAC</span>       <span class="o">=</span> <span class="n">IDAC</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">My_other_IDAC</span> <span class="o">=</span> <span class="n">IDAC</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<p><strong>Parameter:</strong></p>
<ul>
<li><dl class="first docutils">
<dt><em>channel</em> Determines which IDAC is the be utilized</dt>
<dd><ul class="first last simple">
<li><em>0</em> for the first IDAC; output is on P0[7] by default</li>
<li><em>1</em> for the second IDAC; not available by default</li>
</ul>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="analog.IDAC.SetCurrent">
<tt class="descname">SetCurrent</tt><big>(</big><em>amps</em><big>)</big><a class="headerlink" href="#analog.IDAC.SetCurrent" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Description:</strong>
Sets a current in milliamps to be output on the specified IDAC. Valid values depend on the chosen full scale range</p>
<p><strong>Parameters:</strong>
- <em>amps</em>: number between 0 and the full scale range in milliamperes.
* The full scale value depends on the range, which is chosen with the SetRange() method.</p>
</dd></dl>

<dl class="method">
<dt id="analog.IDAC.SetPolarity">
<tt class="descname">SetPolarity</tt><big>(</big><em>polarity</em><big>)</big><a class="headerlink" href="#analog.IDAC.SetPolarity" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the DAC output polarity.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><em>polarity:</em> <em>SOURCE</em> or <em>SINK</em></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.IDAC.SetRange">
<tt class="descname">SetRange</tt><big>(</big><em>mode</em><big>)</big><a class="headerlink" href="#analog.IDAC.SetRange" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the Full scale range for the IDAC</dd>
<dt><strong>Parameter:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><em>mode:</em> <em>0, 1, or 2</em></dt>
<dd><ul class="first last simple">
<li><em>0</em>: Sets full scale range to <strong>31.875 uA</strong></li>
<li><em>1</em>: Sets full scale range to <strong>255 uA</strong></li>
<li><em>2</em>: Sets full scale range to <strong>2.04 mA</strong></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.IDAC.SetSpeed">
<tt class="descname">SetSpeed</tt><big>(</big><em>speed</em><big>)</big><a class="headerlink" href="#analog.IDAC.SetSpeed" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the DAC speed, and consequently the power level.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>speed: <em>HIGH</em> or <em>LOW</em></dt>
<dd><ul class="first last simple">
<li><em>HIGH</em> speed puts the DAC in high power mode</li>
<li><em>LOW</em> speed puts the DAC in low power mode.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.IDAC.SetValue">
<tt class="descname">SetValue</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#analog.IDAC.SetValue" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets value to output on IDAC. Valid values are between 0 and 255.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><em>value</em>: number between 0 and 255.</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>A value of 0 is the lowest and a value of 255 is the full-scale value.</dt>
<dd><ul class="first last simple">
<li>The full-scale value depends on the range, which is selected with SetRange()</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.IDAC.Sleep">
<tt class="descname">Sleep</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.IDAC.Sleep" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>The IDAC Sleep function checks to see if the component is enabled, then it stops the IDAC and saves the current configuration for later use.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.IDAC.Start">
<tt class="descname">Start</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.IDAC.Start" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the initVar variable on the RPiSoC, calls the IDAC8_Init() function and then calls the IDAC8_Enable() function. Enables and powers up the IDAC</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.IDAC.Stop">
<tt class="descname">Stop</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.IDAC.Stop" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Powers down IDAC to lowest power state and disables output.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.IDAC.Wakeup">
<tt class="descname">Wakeup</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.IDAC.Wakeup" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Restores the most recently saved IDAC configuration so that it can be restarted.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="analog.VDAC">
<em class="property">class </em><tt class="descclassname">analog.</tt><tt class="descname">VDAC</tt><big>(</big><em>channel</em><big>)</big><a class="headerlink" href="#analog.VDAC" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd><p class="first">The VDAC class provides functionality for using the VDAC&#8217;s available on the RPiSoC. Define VDAC objects in the following
way:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">My_VDAC</span>       <span class="o">=</span> <span class="n">VDAC</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">My_other_VDAC</span> <span class="o">=</span> <span class="n">VDAC</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<p><strong>Parameters:</strong></p>
<ul>
<li><dl class="first docutils">
<dt><em>channel:</em> Determines which VDAC is to be utilized</dt>
<dd><ul class="first last simple">
<li><em>0</em> for the first VDAC; output is on P0[1] by default</li>
<li><em>1</em> for the second VDAC; not available by default</li>
</ul>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="analog.VDAC.SetRange">
<tt class="descname">SetRange</tt><big>(</big><em>Range</em><big>)</big><a class="headerlink" href="#analog.VDAC.SetRange" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the Full scale range for the IDAC</dd>
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><em>Range:</em> <em>HIGH</em> or <em>LOW</em></dt>
<dd><ul class="first last simple">
<li><em>HIGH:</em> Sets full scale range to <strong>4.080V</strong></li>
<li><em>LOW :</em> Sets full scale range to <strong>1.020V</strong></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.VDAC.SetSpeed">
<tt class="descname">SetSpeed</tt><big>(</big><em>speed</em><big>)</big><a class="headerlink" href="#analog.VDAC.SetSpeed" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the DAC speed, and consequently the power level.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><em>speed:</em> <em>HIGH</em> or <em>LOW</em></dt>
<dd><ul class="first last simple">
<li><em>HIGH</em> speed puts the DAC in high power mode</li>
<li><em>LOW</em> speed puts the DAC in low power mode</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.VDAC.SetValue">
<tt class="descname">SetValue</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#analog.VDAC.SetValue" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets value to output on VDAC.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><em>value:</em> integer between <em>0</em> and <em>255.</em></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>A value of <em>0</em> is the lowest and a value of <em>255</em> is the full-scale value.</dt>
<dd><ul class="first last simple">
<li>The full-scale value depends on the range, which is selected with SetRange()</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.VDAC.SetVoltage">
<tt class="descname">SetVoltage</tt><big>(</big><em>volts</em><big>)</big><a class="headerlink" href="#analog.VDAC.SetVoltage" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Description:</strong>
Sets a voltage in Volts to be output on the specified VDAC. Valid values depend on the chosen full scale range</p>
<p><strong>Parameters:</strong>
- <em>volts</em>: number between 0 and the full scale range in Volts.
* The full scale value depends on the range, which is chosen with the SetRange() method.</p>
</dd></dl>

<dl class="method">
<dt id="analog.VDAC.Sleep">
<tt class="descname">Sleep</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.VDAC.Sleep" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Checks to see if the component is enabled, then it stops the VDAC and saves the current configuration for later use.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.VDAC.Start">
<tt class="descname">Start</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.VDAC.Start" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the initVar variable on the RPiSoC, calls the VDAC8_Init() function and then calls the VDAC8_Enable() function. Enables and powers up the IDAC</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.VDAC.Stop">
<tt class="descname">Stop</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.VDAC.Stop" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Powers down the VDAC to lowest power state and disables output.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.VDAC.Wakeup">
<tt class="descname">Wakeup</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.VDAC.Wakeup" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Restores the most recently saved VDAC configuration so that it can be restarted.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="analog.WaveDAC">
<em class="property">class </em><tt class="descclassname">analog.</tt><tt class="descname">WaveDAC</tt><a class="headerlink" href="#analog.WaveDAC" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd><p class="first">The WaveDAC class provides functionality for using the WaveDAC available on the RPiSoC. Define WaveDAC objects in the following
way:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">My_Wave</span> <span class="o">=</span> <span class="n">WaveDAC</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
<dl class="method">
<dt id="analog.WaveDAC.Generate_Wave">
<tt class="descname">Generate_Wave</tt><big>(</big><em>waveType</em><big>)</big><a class="headerlink" href="#analog.WaveDAC.Generate_Wave" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Provides functionality for generating a specific waveform. It uses the class attributes <em>self.amplitude</em> and <em>self.dcB,</em> which define
the waveforms peak voltage and the DC Bias, respectively. These are defaulted to 4V amplitude and 0V DC Bias, unless modifed by using the <em>setAmplitude()</em> and <em>setdcBias()</em> functions.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><em>waveType:</em> string</dt>
<dd><ul class="first last simple">
<li><em>SINE</em></li>
<li><em>SQUARE</em></li>
<li><em>TRIANGLE</em></li>
<li><em>SAWTOOTH</em></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p><strong>Note:</strong> <em>V1.3</em> intends to introduce defining your own custom waveforms.</p>
</dd></dl>

<dl class="method">
<dt id="analog.WaveDAC.GetFrequency">
<tt class="descname">GetFrequency</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.WaveDAC.GetFrequency" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Calculates the actual wave frequency based on the most recently confirmed clock divider value.</dd>
<dt><strong>Returns:</strong></dt>
<dd>The <em>actual</em> frequency of the wave, <em>not</em> of the requested frequency.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.WaveDAC.SetFrequency">
<tt class="descname">SetFrequency</tt><big>(</big><em>frequency</em><big>)</big><a class="headerlink" href="#analog.WaveDAC.SetFrequency" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets an approximate frequency by using an appropriate clock divider so that the resulting wave is as close to the desired frequency as possible.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last simple">
<li><em>frequency:</em> A frequency in Hz between <em>0</em> and <em>2500.</em></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.WaveDAC.SetSpeed">
<tt class="descname">SetSpeed</tt><big>(</big><em>speed</em><big>)</big><a class="headerlink" href="#analog.WaveDAC.SetSpeed" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the drive mode / speed to one of the settings.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><em>speed:</em> <em>HIGH</em> or <em>LOW</em></dt>
<dd><ul class="first last simple">
<li><em>HIGH :</em> Highest power and fastest slew rate</li>
<li><em>LOW  :</em> Lowest active power and slowest slew rate</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.WaveDAC.SetValue">
<tt class="descname">SetValue</tt><big>(</big><em>val</em><big>)</big><a class="headerlink" href="#analog.WaveDAC.SetValue" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets the output of the DAC to the desired value. It is preferable to use this function when
the clock is stopped. If this function is used during normal operation (clock is running), the
predefined waveform may be interrupted.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last simple">
<li><em>val:</em> 8-bit DAC value between <em>0</em> and <em>255</em></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.WaveDAC.Sleep">
<tt class="descname">Sleep</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.WaveDAC.Sleep" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Checks to see if the component is enabled, then it stops the WaveDAC and saves the current configuration for later use.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.WaveDAC.Start">
<tt class="descname">Start</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.WaveDAC.Start" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Performs all of the required initialization for the component and enables power to the block.
The first time the routine is executed, the range, polarity (if any), and power (speed)
settings are configured for the operating mode selected in the design. When called to
restart the WaveDAC8 following a Stop() call, the current component parameter settings are retained.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.WaveDAC.StartClock">
<tt class="descname">StartClock</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.WaveDAC.StartClock" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Restarts the WaveDAC clock after it has been stopped.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.WaveDAC.Stop">
<tt class="descname">Stop</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.WaveDAC.Stop" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Turn off the WaveDAC8 block.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.WaveDAC.StopClock">
<tt class="descname">StopClock</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.WaveDAC.StopClock" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Stops the WaveDAC clock so that a value can be set without interference by the clock.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.WaveDAC.Wakeup">
<tt class="descname">Wakeup</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.WaveDAC.Wakeup" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Restores the most recently saved WaveDAC configuration so that it can be restarted.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.WaveDAC.setAmplitude">
<tt class="descname">setAmplitude</tt><big>(</big><em>amplitude</em><big>)</big><a class="headerlink" href="#analog.WaveDAC.setAmplitude" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Modifies the class attribute associated with peak voltage of a generated wave.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><em>amplitude:</em> a peak amplitude, in Volts, between <em>0</em> and <em>4.</em></dt>
<dd><ul class="first last simple">
<li>The amplitude can be greater than 4V, but the output will saturate at 4.080 V.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.WaveDAC.setdcBias">
<tt class="descname">setdcBias</tt><big>(</big><em>dcBias</em><big>)</big><a class="headerlink" href="#analog.WaveDAC.setdcBias" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Modifies the class attribute associated withthe DC Bias of a generated wave.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><em>dcBias:</em> a DC Bias, in Volts, between <em>0</em> and <em>4.</em></dt>
<dd><ul class="first last simple">
<li>The generated wave will be offset by this amount.</li>
<li>The DC Bias can be greater than 4 Volts, but the output will saturate at 4.080 V.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="analog.analogPin">
<em class="property">class </em><tt class="descclassname">analog.</tt><tt class="descname">analogPin</tt><big>(</big><em>PIN</em><big>)</big><a class="headerlink" href="#analog.analogPin" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd><p class="first">Provides functionality for use of the analog pins exposed on the RPiSoC. Define an analogPin object in the following
way:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">My_analog_pin</span> <span class="o">=</span> <span class="n">analogPin</span><span class="p">(</span><span class="n">PIN</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<p><strong>Parameters:</strong></p>
<ul>
<li><dl class="first docutils">
<dt><em>PIN</em>: The analog pin number - This directly corresponds to the pins connected to your sequenced SAR ADC, where 0 is the top pin.</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>The following is valid for the default version of the API (v1.2) which containts 8 analog pins.</dt>
<dd><ul class="first last simple">
<li>Valid arguments are between <em>0</em> and <em>7</em></li>
<li>PINs <em>0-7</em> are relative to Port 3. So PIN = 0 an analog pin on Port 3 Pin 0 (P3[0]), and PIN = 7 is on Port 3 Pin 7 (P3[7])</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="analog.analogPin.Read">
<tt class="descname">Read</tt><big>(</big><big>)</big><a class="headerlink" href="#analog.analogPin.Read" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Reads the specified analog pin</dd>
<dt><strong>Returns:</strong></dt>
<dd>Value in <em>counts</em> which represents the digital value after an A/D conversion on the specified pin. The voltage the is represented by the count value will depend on the resolution set by the SetResolution() method</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.analogPin.ReadVolts">
<tt class="descname">ReadVolts</tt><big>(</big><em>PRECISION=2</em><big>)</big><a class="headerlink" href="#analog.analogPin.ReadVolts" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Reads the specified analog pin and converts that digital reading to a voltage in Volts.</dd>
<dt><strong>Optional Parameters:</strong></dt>
<dd><dl class="first last docutils">
<dt><em>PRECISION:</em> The number of decimal points the voltage will be rounded to.</dt>
<dd><ul class="first last simple">
<li>The default value is 2, but precision up to 5 points is available.</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>Returns:</strong></dt>
<dd>Value in <em>Volts</em> which is being applied to the specified analog pin. The resolution of the ADC does not affect this method; the conversion process accounts for the ADC resolution.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.analogPin.SetOffset">
<tt class="descname">SetOffset</tt><big>(</big><em>counts</em><big>)</big><a class="headerlink" href="#analog.analogPin.SetOffset" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd>Sets an offset on the ADC which is used by the CountsTo_Volts function. It will subtract the given offset before making the conversion.</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last simple">
<li><em>offset</em>: ADC Value in <em>counts</em>, which will be used by the <em>CountsTo_Volts()</em> function by subtracting the given offset before making the conversion.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="analog.analogPin.SetResolution">
<tt class="descname">SetResolution</tt><big>(</big><em>resolution</em><big>)</big><a class="headerlink" href="#analog.analogPin.SetResolution" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt><strong>Description:</strong></dt>
<dd><ul class="first last simple">
<li>This function sets the resolution of ALL analogPin objects. The resolution is defaulted to 12.</li>
</ul>
</dd>
<dt><strong>Parameters:</strong></dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt><em>resolution:</em> An integer value, in bits, that represents the new resolution of the SAR ADC.</dt>
<dd><ul class="first last simple">
<li>Valid entries are <em>8, 10, or 12.</em></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>Side Effects:</strong></dt>
<dd><ul class="first last simple">
<li>The ADC resolution cannot be changed during a conversion cycle. The recommended bestpractice is to stop conversions with <em>Stop()</em> before changint the resolution, and then restarting with <em>Start().</em> If you call <em>SetResolution()</em> during a conversion, the resolution will not change until the current conversion is complete. Data will not be available in the new resolution for another 6 + <em>resolution</em> clock cycles. You may need add a delay of this number of clock cycles after <em>SetResolution()</em> is called before data is valid again.</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p><em>Code author: Brian Bradley &lt;<a class="reference external" href="mailto:embedit&#37;&#52;&#48;embeditelectronics&#46;com">embedit<span>&#64;</span>embeditelectronics<span>&#46;</span>com</a>&gt;</em></p>
<p><em>Section author: Brian Bradley &lt;<a class="reference external" href="mailto:embedit&#37;&#52;&#48;embeditelectronics&#46;com">embedit<span>&#64;</span>embeditelectronics<span>&#46;</span>com</a>&gt;</em></p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/Embedit_flat.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">API modules</a><ul>
<li><a class="reference internal" href="#rpisoc-py">rpisoc.py</a></li>
<li><a class="reference internal" href="#module-digital">digital.py</a></li>
<li><a class="reference internal" href="#module-analog">analog.py</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="getting_started.html"
                        title="previous chapter">Getting Started</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="making_changes.html"
                        title="next chapter">Making Changes to the API</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/code.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="making_changes.html" title="Making Changes to the API"
             >next</a> |</li>
        <li class="right" >
          <a href="getting_started.html" title="Getting Started"
             >previous</a> |</li>
        <li><a href="index.html">RPiSoC Python API 1.2.4 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Embedit Electronics.
      Last updated on Dec 10, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>